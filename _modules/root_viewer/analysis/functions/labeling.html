<!DOCTYPE html> <html lang=en > <meta charset=utf-8  /> <meta name=viewport  content="width=device-width, initial-scale=1.0" /> <meta name=viewport  content="width=device-width,initial-scale=1"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name="lang:clipboard.copy" content="Copy to clipboard"> <meta name="lang:clipboard.copied" content="Copied to clipboard"> <meta name="lang:search.language" content=en > <meta name="lang:search.pipeline.stopwords" content=True > <meta name="lang:search.pipeline.trimmer" content=True > <meta name="lang:search.result.none" content="No matching documents"> <meta name="lang:search.result.one" content="1 matching document"> <meta name="lang:search.result.other" content="# matching documents"> <meta name="lang:search.tokenizer" content="[\s\-]+"> <link href="https://fonts.gstatic.com/" rel=preconnect  crossorigin> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel=stylesheet > <style> body, input { font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif } code, kbd, pre { font-family: "Roboto Mono", "Courier New", Courier, monospace } </style> <link rel=stylesheet  href="../../../../_static/stylesheets/application.css"/> <link rel=stylesheet  href="../../../../_static/stylesheets/application-palette.css"/> <link rel=stylesheet  href="../../../../_static/stylesheets/application-fixes.css"/> <link rel=stylesheet  href="../../../../_static/fonts/material-icons.css"/> <meta name=theme-color  content="#51DBBA"> <script src="../../../../_static/javascripts/modernizr.js"></script> <title>root_viewer.analysis.functions.labeling &#8212; Root Viewer</title> <link rel=stylesheet  type="text/css" href="../../../../_static/pygments.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/togglebutton.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/copybutton.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/mystnb.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/sphinx-thebe.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <script data-url_root="../../../../" id=documentation_options  src="../../../../_static/documentation_options.js"></script> <script src="../../../../_static/jquery.js"></script> <script src="../../../../_static/underscore.js"></script> <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script> <script src="../../../../_static/doctools.js"></script> <script src="../../../../_static/sphinx_highlight.js"></script> <script src="../../../../_static/clipboard.min.js"></script> <script src="../../../../_static/copybutton.js"></script> <script src="../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script> <script>let toggleHintShow = 'Click to show';</script> <script>let toggleHintHide = 'Click to hide';</script> <script>let toggleOpenOnPrint = 'true';</script> <script src="../../../../_static/togglebutton.js"></script> <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script> <script src="../../../../_static/design-tabs.js"></script> <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js" const thebe_selector = ".thebe,.cell" const thebe_selector_input = "pre" const thebe_selector_output = ".output, .cell_output" </script> <script async=async  src="../../../../_static/sphinx-thebe.js"></script> <link rel="shortcut icon" href="../../../../_static/favicon.ico"/> <link rel=index  title=Index  href="../../../../genindex.html" /> <link rel=search  title=Search  href="../../../../search.html" /> <body dir=ltr data-md-color-primary=dark-blue data-md-color-accent=#66E0F2> <svg class=md-svg > <defs data-children-count=0 > <svg xmlns="http://www.w3.org/2000/svg" width=416  height=448  viewBox="0 0 416 448" id=__github ><path fill=currentColor  d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle  data-md-toggle=drawer  type=checkbox  id=__drawer > <input class=md-toggle  data-md-toggle=search  type=checkbox  id=__search > <label class=md-overlay  data-md-component=overlay  for=__drawer ></label> <a href="#_modules/root_viewer/analysis/functions/labeling" tabindex=1  class=md-skip > Skip to content </a> <header class=md-header  data-md-component=header > <nav class="md-header-nav md-grid"> <div class="md-flex navheader"> <div class="md-flex__cell md-flex__cell--shrink"> <a href="../../../../intro.html" title="Root Viewer" class="md-header-nav__button md-logo"> <img src="../../../../_static/logo_dark.png" height=26  alt="Root Viewer logo"> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer ></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title > <span class=md-header-nav__topic >Root Viewer</span> <span class=md-header-nav__topic > root_viewer.analysis.functions.labeling </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search ></label> <div class=md-search  data-md-component=search  role=dialog > <label class=md-search__overlay  for=__search ></label> <div class=md-search__inner  role=search > <form class=md-search__form  action="../../../../search.html" method=get  name=search > <input type=text  class=md-search__input  name=q  placeholder=Search  autocapitalize=off  autocomplete=off  spellcheck=false  data-md-component=query  data-md-state=active > <label class="md-icon md-search__icon" for=__search ></label> <button type=reset  class="md-icon md-search__icon" data-md-component=reset  tabindex=-1 > &#xE5CD; </button> </form> <div class=md-search__output > <div class=md-search__scrollwrap  data-md-scrollfix> <div class=md-search-result  data-md-component=result > <div class=md-search-result__meta > Type to start searching </div> <ol class=md-search-result__list ></ol> </div> </div> </div> </div> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source > <a href="https://github.com/wildrootlab/root-viewer" title="Go to repository" class=md-source  data-md-source=github > <div class=md-source__icon > <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width=28  height=28 > <use xlink:href="#__github" width=24  height=24 ></use> </svg> </div> <div class=md-source__repository > wildrood/root-viewer </div> </a> </div> </div> <script src="../../../../_static/javascripts/version_dropdown.js"></script> <script> var json_loc = "../../../../"versions.json"", target_loc = "../../../../../", text = "Versions"; $( document ).ready( add_version_dropdown(json_loc, target_loc, text)); </script> </div> </nav> </header> <div class=md-container > <main class=md-main > <div class="md-main__inner md-grid" data-md-component=container > <div class="md-sidebar md-sidebar--primary" data-md-component=navigation > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--primary" data-md-level=0 > <div class=md-nav__source > <a href="https://github.com/wildrootlab/root-viewer" title="Go to repository" class=md-source  data-md-source=github > <div class=md-source__icon > <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width=28  height=28 > <use xlink:href="#__github" width=24  height=24 ></use> </svg> </div> <div class=md-source__repository > wildrood/root-viewer </div> </a> </div> <ul class=md-nav__list > <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Getting started</span></span> <li class=md-nav__item > <a href="../../../../intro/installation.html" class=md-nav__link >Installation</a> <li class=md-nav__item > <a href="../../../../intro/quickstart.html" class=md-nav__link >Quickstart</a> <li class=md-nav__item > <a href="../../../../intro/layers.html" class=md-nav__link >Layers</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Segmentation</span></span> <li class=md-nav__item > <a href="../../../../usage/Advanced.html" class=md-nav__link >Advanced Segmentations</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Image Functions</span></span> <li class=md-nav__item > <a href="../../../../usage/Filtering.html" class=md-nav__link >Filtering</a> <li class=md-nav__item > <a href="../../../../usage/Thresholding.html" class=md-nav__link >Thresholding</a> <li class=md-nav__item > <a href="../../../../usage/Labeling.html" class=md-nav__link >Labeling</a> <li class=md-nav__item > <a href="../../../../usage/Misc.html" class=md-nav__link >Misc</a> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--secondary"> <ul class=md-nav__list  data-md-scrollfix=""> </ul> </nav> </div> </div> </div> <div class=md-content > <article class="md-content__inner md-typeset" role=main > <h1 id=modules-root-viewer-analysis-functions-labeling--page-root >Source code for root_viewer.analysis.functions.labeling</h1><div class=highlight ><pre>
<span></span><span class=kn >from</span> <span class=nn >napari.types</span> <span class=kn >import</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >LabelsData</span>
<span class=kn >import</span> <span class=nn >numpy</span> <span class=k >as</span> <span class=nn >np</span>
<span class=kn >from</span> <span class=nn >skimage.filters</span> <span class=kn >import</span> <span class=n >threshold_otsu</span><span class=p >,</span> <span class=n >gaussian</span>
<span class=kn >from</span> <span class=nn >skimage.morphology</span> <span class=kn >import</span> <span class=n >local_maxima</span><span class=p >,</span> <span class=n >local_minima</span>
<span class=kn >from</span> <span class=nn >skimage.measure</span> <span class=kn >import</span> <span class=n >label</span><span class=p >,</span> <span class=n >regionprops</span>
<span class=kn >from</span> <span class=nn >skimage.segmentation</span> <span class=kn >import</span> <span class=n >relabel_sequential</span> <span class=k >as</span> <span class=n >_relabel_sequential</span><span class=p >,</span> <span class=n >clear_border</span> <span class=k >as</span> <span class=n >_clear_border</span><span class=p >,</span> <span class=n >expand_labels</span><span class=p >,</span> <span class=n >watershed</span> <span class=k >as</span> <span class=n >_watershed</span><span class=p >,</span> <span class=n >random_walker</span> <span class=k >as</span> <span class=n >_random_walker</span>

<div class=viewcode-block  id=remove_labels_on_edges ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.remove_labels_on_edges.html#root_viewer.analysis.functions.labeling.remove_labels_on_edges">[docs]</a><span class=k >def</span> <span class=nf >remove_labels_on_edges</span><span class=p >(</span><span class=n >label_image</span><span class=p >:</span> <span class=n >LabelsData</span><span class=p >,</span> <span class=n >buffer_size</span><span class=p >:</span><span class=nb >int</span> <span class=o >=</span> <span class=mi >1</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Clear objects connected to the label image border.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    labels : (M[, N[, ..., P]]) array of int or bool</span>
<span class=sd >        Imaging data labels.</span>
<span class=sd >    </span>
<span class=sd >    buffer_size : int, optional</span>
<span class=sd >        The width of the border examined.  By default, only objects</span>
<span class=sd >        that touch the outside of the image are removed.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    out : ndarray</span>
<span class=sd >        Imaging data labels with cleared borders</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    &gt;&gt;&gt; import numpy as np</span>
<span class=sd >    &gt;&gt;&gt; from skimage.segmentation import clear_border</span>
<span class=sd >    &gt;&gt;&gt; labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class=sd >    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],</span>
<span class=sd >    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],</span>
<span class=sd >    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class=sd >    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    &gt;&gt;&gt; clear_border(labels)</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    &gt;&gt;&gt; mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)</span>
<span class=sd >    &gt;&gt;&gt; clear_border(labels, mask=mask)</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class=sd >           [0, 0, 0, 0, 1, 0, 0, 1, 0],</span>
<span class=sd >           [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    """</span>

    <span class=n >result</span> <span class=o >=</span> <span class=n >_clear_border</span><span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >label_image</span><span class=p >),</span> <span class=n >buffer_size</span><span class=o >=</span><span class=n >buffer_size</span><span class=p >)</span>
    <span class=n >relabeled_result</span><span class=p >,</span> <span class=n >_</span><span class=p >,</span> <span class=n >_</span> <span class=o >=</span> <span class=n >_relabel_sequential</span><span class=p >(</span><span class=n >result</span><span class=p >)</span>
    <span class=k >return</span> <span class=n >relabeled_result</span></div>


<div class=viewcode-block  id=expand_labels ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.expand_labels.html#root_viewer.analysis.functions.labeling.expand_labels">[docs]</a><span class=k >def</span> <span class=nf >expand_labels</span><span class=p >(</span><span class=n >label_image</span><span class=p >:</span> <span class=n >LabelsData</span><span class=p >,</span> <span class=n >distance</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >1</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Expand labels in label image by ``distance`` pixels without overlapping.</span>
<span class=sd >    Given a label image, ``expand_labels`` grows label regions (connected components)</span>
<span class=sd >    outwards by up to ``distance`` pixels without overflowing into neighboring regions.</span>
<span class=sd >    More specifically, each background pixel that is within Euclidean distance</span>
<span class=sd >    of &lt;= ``distance`` pixels of a connected component is assigned the label of that</span>
<span class=sd >    connected component.</span>
<span class=sd >    Where multiple connected components are within ``distance`` pixels of a background</span>
<span class=sd >    pixel, the label value of the closest connected component will be assigned (see</span>
<span class=sd >    Notes for the case of multiple labels at equal distance).</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    label_image : ndarray of dtype int</span>
<span class=sd >        label image</span>
<span class=sd >    distance : float</span>
<span class=sd >        Euclidean distance in pixels by which to grow the labels. Default is one.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    enlarged_labels : ndarray of dtype int</span>
<span class=sd >        Labeled array, where all connected regions have been enlarged</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    Where labels are spaced more than ``distance`` pixels are apart, this is</span>
<span class=sd >    equivalent to a morphological dilation with a disc or hyperball of radius ``distance``.</span>
<span class=sd >    However, in contrast to a morphological dilation, ``expand_labels`` will</span>
<span class=sd >    not expand a label region into a neighboring region.</span>
<span class=sd >    This implementation of ``expand_labels`` is derived from CellProfiler [1]_, where</span>
<span class=sd >    it is known as module "IdentifySecondaryObjects (Distance-N)" [2]_.</span>
<span class=sd >    There is an important edge case when a pixel has the same distance to</span>
<span class=sd >    multiple regions, as it is not defined which region expands into that</span>
<span class=sd >    space. Here, the exact behavior depends on the upstream implementation</span>
<span class=sd >    of ``scipy.ndimage.distance_transform_edt``.</span>
<span class=sd >    </span>
<span class=sd >    See Also</span>
<span class=sd >    --------</span>
<span class=sd >    :func:`skimage.measure.label`, :func:`skimage.segmentation.watershed`, :func:`skimage.morphology.dilation`</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://cellprofiler.org</span>
<span class=sd >    .. [2] https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    &gt;&gt;&gt; labels = np.array([0, 1, 0, 0, 0, 0, 2])</span>
<span class=sd >    &gt;&gt;&gt; expand_labels(labels, distance=1)</span>
<span class=sd >    array([1, 1, 1, 0, 0, 2, 2])</span>
<span class=sd >    Labels will not overwrite each other:</span>
<span class=sd >    &gt;&gt;&gt; expand_labels(labels, distance=3)</span>
<span class=sd >    array([1, 1, 1, 1, 2, 2, 2])</span>
<span class=sd >    In case of ties, behavior is undefined, but currently resolves to the</span>
<span class=sd >    label closest to ``(0,) * ndim`` in lexicographical order.</span>
<span class=sd >    &gt;&gt;&gt; labels_tied = np.array([0, 1, 0, 2, 0])</span>
<span class=sd >    &gt;&gt;&gt; expand_labels(labels_tied, 1)</span>
<span class=sd >    array([1, 1, 1, 2, 2])</span>
<span class=sd >    &gt;&gt;&gt; labels2d = np.array(</span>
<span class=sd >    ...     [[0, 1, 0, 0],</span>
<span class=sd >    ...      [2, 0, 0, 0],</span>
<span class=sd >    ...      [0, 3, 0, 0]]</span>
<span class=sd >    ... )</span>
<span class=sd >    &gt;&gt;&gt; expand_labels(labels2d, 1)</span>
<span class=sd >    array([[2, 1, 1, 0],</span>
<span class=sd >           [2, 2, 0, 0],</span>
<span class=sd >           [2, 3, 3, 0]])</span>
<span class=sd >    </span>
<span class=sd >    .. image:: ../../images/skimage/sphx_glr_plot_expand_labels_001.png</span>
<span class=sd >    """</span>

    <span class=k >return</span> <span class=n >expand_labels</span><span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >label_image</span><span class=p >),</span> <span class=n >distance</span><span class=o >=</span><span class=n >distance</span><span class=p >)</span></div>


<div class=viewcode-block  id=voronoi_otsu_labeling ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.voronoi_otsu_labeling.html#root_viewer.analysis.functions.labeling.voronoi_otsu_labeling">[docs]</a><span class=k >def</span> <span class=nf >voronoi_otsu_labeling</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >spot_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Voronoi-Otsu-Labeling is a segmentation algorithm for blob-like structures such as nuclei and granules with high signal intensity on low-intensity background. </span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    spot_sigma : float, optional</span>
<span class=sd >        Standard deviation of the Gaussian kernel used to smooth the image. Controls how close detected cells can be</span>
<span class=sd >    outline_sigma : float, optional</span>
<span class=sd >        Standard deviation of the Gaussian kernel used to smooth the outlines. Controls how precise segmented objects are.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    labels : ndarray</span>
<span class=sd >        Labeled image.</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://github.com/clEsperanto/pyclesperanto_prototype/blob/master/demo/segmentation/voronoi_otsu_labeling.ipynb</span>
<span class=sd >    """</span>
    <span class=n >image</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >image</span><span class=p >)</span>

    <span class=c1 ># blur and detect local maxima</span>
    <span class=n >blurred_spots</span> <span class=o >=</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >spot_sigma</span><span class=p >)</span>
    <span class=n >spot_centroids</span> <span class=o >=</span> <span class=n >local_maxima</span><span class=p >(</span><span class=n >blurred_spots</span><span class=p >)</span>

    <span class=c1 ># blur and threshold</span>
    <span class=n >blurred_outline</span> <span class=o >=</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >)</span>
    <span class=n >threshold</span> <span class=o >=</span> <span class=n >threshold_otsu</span><span class=p >(</span><span class=n >blurred_outline</span><span class=p >)</span>
    <span class=n >binary_otsu</span> <span class=o >=</span> <span class=n >blurred_outline</span> <span class=o >&gt;</span> <span class=n >threshold</span>

    <span class=c1 ># determine local maxima within the thresholded area</span>
    <span class=n >remaining_spots</span> <span class=o >=</span> <span class=n >spot_centroids</span> <span class=o >*</span> <span class=n >binary_otsu</span>

    <span class=c1 ># start from remaining spots and flood binary image with labels</span>
    <span class=n >labeled_spots</span> <span class=o >=</span> <span class=n >label</span><span class=p >(</span><span class=n >remaining_spots</span><span class=p >)</span>
    <span class=n >labels</span> <span class=o >=</span> <span class=n >_watershed</span><span class=p >(</span><span class=n >binary_otsu</span><span class=p >,</span> <span class=n >labeled_spots</span><span class=p >,</span> <span class=n >mask</span><span class=o >=</span><span class=n >binary_otsu</span><span class=p >)</span>

    <span class=k >return</span> <span class=n >labels</span></div>


<div class=viewcode-block  id=gauss_otsu_labeling ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.gauss_otsu_labeling.html#root_viewer.analysis.functions.labeling.gauss_otsu_labeling">[docs]</a><span class=k >def</span> <span class=nf >gauss_otsu_labeling</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Gauss-Otsu-Labeling can be used to segment objects such as nuclei with bright intensity on</span>
<span class=sd >    low intensity background images.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    outline_sigma : float, optional</span>
<span class=sd >        Standard deviation of the Gaussian kernel used to smooth the outlines. Controls how precise segmented objects are.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    labels : ndarray</span>
<span class=sd >        Labeled image.</span>
<span class=sd >    """</span>
    <span class=n >image</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >image</span><span class=p >)</span>

    <span class=c1 ># blur</span>
    <span class=n >blurred_outline</span> <span class=o >=</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >)</span>

    <span class=c1 ># threshold</span>
    <span class=n >threshold</span> <span class=o >=</span> <span class=n >threshold_otsu</span><span class=p >(</span><span class=n >blurred_outline</span><span class=p >)</span>
    <span class=n >binary_otsu</span> <span class=o >=</span> <span class=n >blurred_outline</span> <span class=o >&gt;</span> <span class=n >threshold</span>

    <span class=c1 ># connected component labeling</span>
    <span class=n >labels</span> <span class=o >=</span> <span class=n >label</span><span class=p >(</span><span class=n >binary_otsu</span><span class=p >)</span>

    <span class=k >return</span> <span class=n >labels</span></div>


<div class=viewcode-block  id=seeded_watershed ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.seeded_watershed.html#root_viewer.analysis.functions.labeling.seeded_watershed">[docs]</a><span class=k >def</span> <span class=nf >seeded_watershed</span><span class=p >(</span><span class=n >membranes</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >labels</span><span class=p >:</span><span class=n >LabelsData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Finds the watershed basins in `image` flooded from given `labels`.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray (2-D, 3-D, ...)</span>
<span class=sd >        Data array where the lowest value points are labeled first.</span>
<span class=sd >    labels : int, or ndarray of int, same shape as `image`, optional</span>
<span class=sd >        The desired number of markers, or an array marking the basins with the</span>
<span class=sd >        values to be assigned in the label matrix. Zero means not a marker. If</span>
<span class=sd >        ``None`` (no markers given), the local minima of the image are used as</span>
<span class=sd >        markers.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    out : ndarray</span>
<span class=sd >        A labeled matrix of the same type and shape as markers</span>
<span class=sd >    </span>
<span class=sd >    See Also</span>
<span class=sd >    --------</span>
<span class=sd >    random_walker : random walker segmentation</span>
<span class=sd >        A segmentation algorithm based on anisotropic diffusion, usually</span>
<span class=sd >        slower than the watershed but with good results on noisy data and</span>
<span class=sd >        boundaries with holes.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    This function implements a watershed algorithm [1]_ [2]_ that apportions</span>
<span class=sd >    pixels into marked basins. The algorithm uses a priority queue to hold</span>
<span class=sd >    the pixels with the metric for the priority queue being pixel value, then</span>
<span class=sd >    the time of entry into the queue - this settles ties in favor of the</span>
<span class=sd >    closest marker.</span>
<span class=sd >    Some ideas taken from</span>
<span class=sd >    Soille, "Automated Basin Delineation from Digital Elevation Models Using</span>
<span class=sd >    Mathematical Morphology", Signal Processing 20 (1990) 171-182</span>
<span class=sd >    The most important insight in the paper is that entry time onto the queue</span>
<span class=sd >    solves two problems: a pixel should be assigned to the neighbor with the</span>
<span class=sd >    largest gradient or, if there is no gradient, pixels on a plateau should</span>
<span class=sd >    be split between markers on opposite sides.</span>
<span class=sd >    This implementation converts all arguments to specific, lowest common</span>
<span class=sd >    denominator types, then passes these to a C algorithm.</span>
<span class=sd >    Markers can be determined manually, or automatically using for example</span>
<span class=sd >    the local minima of the gradient of the image, or the local maxima of the</span>
<span class=sd >    distance function to the background for separating overlapping objects</span>
<span class=sd >    (see example).</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</span>
<span class=sd >    .. [2] http://cmm.ensmp.fr/~beucher/wtshed.html</span>
<span class=sd >    .. [3] Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and</span>
<span class=sd >           Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation</span>
<span class=sd >           Algorithms. ICPR 2014, pp 996-1001. :DOI:`10.1109/ICPR.2014.181`</span>
<span class=sd >           https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</span>
<span class=sd >    """</span>
    <span class=n >cells</span> <span class=o >=</span> <span class=n >_watershed</span><span class=p >(</span>
        <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >membranes</span><span class=p >),</span>
        <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >labels</span><span class=p >)</span>
    <span class=p >)</span>
    <span class=k >return</span> <span class=n >cells</span></div>

<div class=viewcode-block  id=seeded_watershed_with_mask ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.seeded_watershed_with_mask.html#root_viewer.analysis.functions.labeling.seeded_watershed_with_mask">[docs]</a><span class=k >def</span> <span class=nf >seeded_watershed_with_mask</span><span class=p >(</span><span class=n >membranes</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >labels</span><span class=p >:</span><span class=n >LabelsData</span><span class=p >,</span> <span class=n >mask</span><span class=p >:</span><span class=n >LabelsData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >""" Finds the watershed basins in `image` flooded from given `labels` and masks is.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray (2-D, 3-D, ...)</span>
<span class=sd >        Data array where the lowest value points are labeled first.</span>
<span class=sd >    markers : int, or ndarray of int, same shape as `image`, optional</span>
<span class=sd >        The desired number of markers, or an array marking the basins with the</span>
<span class=sd >        values to be assigned in the label matrix. Zero means not a marker. If</span>
<span class=sd >        ``None`` (no markers given), the local minima of the image are used as</span>
<span class=sd >        markers.</span>
<span class=sd >    mask : ndarray of bools or 0s and 1s, optional</span>
<span class=sd >        Array of same shape as `image`. Only points at which mask == True</span>
<span class=sd >        will be labeled.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    out : ndarray</span>
<span class=sd >        A labeled matrix of the same type and shape as markers</span>
<span class=sd >    </span>
<span class=sd >    See Also</span>
<span class=sd >    --------</span>
<span class=sd >    random_walker : random walker segmentation</span>
<span class=sd >        A segmentation algorithm based on anisotropic diffusion, usually</span>
<span class=sd >        slower than the watershed but with good results on noisy data and</span>
<span class=sd >        boundaries with holes.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    This function implements a watershed algorithm [1]_ [2]_ that apportions</span>
<span class=sd >    pixels into marked basins. The algorithm uses a priority queue to hold</span>
<span class=sd >    the pixels with the metric for the priority queue being pixel value, then</span>
<span class=sd >    the time of entry into the queue - this settles ties in favor of the</span>
<span class=sd >    closest marker.</span>
<span class=sd >    Some ideas taken from</span>
<span class=sd >    Soille, "Automated Basin Delineation from Digital Elevation Models Using</span>
<span class=sd >    Mathematical Morphology", Signal Processing 20 (1990) 171-182</span>
<span class=sd >    The most important insight in the paper is that entry time onto the queue</span>
<span class=sd >    solves two problems: a pixel should be assigned to the neighbor with the</span>
<span class=sd >    largest gradient or, if there is no gradient, pixels on a plateau should</span>
<span class=sd >    be split between markers on opposite sides.</span>
<span class=sd >    This implementation converts all arguments to specific, lowest common</span>
<span class=sd >    denominator types, then passes these to a C algorithm.</span>
<span class=sd >    Markers can be determined manually, or automatically using for example</span>
<span class=sd >    the local minima of the gradient of the image, or the local maxima of the</span>
<span class=sd >    distance function to the background for separating overlapping objects</span>
<span class=sd >    (see example).</span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</span>
<span class=sd >    .. [2] http://cmm.ensmp.fr/~beucher/wtshed.html</span>
<span class=sd >    .. [3] Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and</span>
<span class=sd >           Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation</span>
<span class=sd >           Algorithms. ICPR 2014, pp 996-1001. :DOI:`10.1109/ICPR.2014.181`</span>
<span class=sd >           https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    The watershed algorithm is useful to separate overlapping objects.</span>
<span class=sd >    We first generate an initial image with two overlapping circles:</span>
<span class=sd >    </span>
<span class=sd >    &gt;&gt;&gt; x, y = np.indices((80, 80))</span>
<span class=sd >    &gt;&gt;&gt; x1, y1, x2, y2 = 28, 28, 44, 52</span>
<span class=sd >    &gt;&gt;&gt; r1, r2 = 16, 20</span>
<span class=sd >    &gt;&gt;&gt; mask_circle1 = (x - x1)**2 + (y - y1)**2 &lt; r1**2</span>
<span class=sd >    &gt;&gt;&gt; mask_circle2 = (x - x2)**2 + (y - y2)**2 &lt; r2**2</span>
<span class=sd >    &gt;&gt;&gt; image = np.logical_or(mask_circle1, mask_circle2)</span>
<span class=sd >    Next, we want to separate the two circles. We generate markers at the</span>
<span class=sd >    maxima of the distance to the background:</span>
<span class=sd >    &gt;&gt;&gt; from scipy import ndimage as ndi</span>
<span class=sd >    &gt;&gt;&gt; distance = ndi.distance_transform_edt(image)</span>
<span class=sd >    &gt;&gt;&gt; from skimage.feature import peak_local_max</span>
<span class=sd >    &gt;&gt;&gt; max_coords = peak_local_max(distance, labels=image,</span>
<span class=sd >    ...                             footprint=np.ones((3, 3)))</span>
<span class=sd >    &gt;&gt;&gt; local_maxima = np.zeros_like(image, dtype=bool)</span>
<span class=sd >    &gt;&gt;&gt; local_maxima[tuple(max_coords.T)] = True</span>
<span class=sd >    &gt;&gt;&gt; markers = ndi.label(local_maxima)[0]</span>
<span class=sd >    Finally, we run the watershed on the image and markers:</span>
<span class=sd >    &gt;&gt;&gt; labels = watershed(-distance, markers, mask=image)</span>
<span class=sd >    The algorithm works also for 3-D images, and can be used for example to</span>
<span class=sd >    separate overlapping spheres.</span>
<span class=sd >    """</span>
    <span class=n >cells</span> <span class=o >=</span> <span class=n >_watershed</span><span class=p >(</span>
        <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >membranes</span><span class=p >),</span>
        <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >labels</span><span class=p >),</span>
        <span class=n >mask</span><span class=o >=</span><span class=n >mask</span>
    <span class=p >)</span>
    <span class=k >return</span> <span class=n >cells</span></div>

<div class=viewcode-block  id=random_walker ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.random_walker.html#root_viewer.analysis.functions.labeling.random_walker">[docs]</a><span class=k >def</span> <span class=nf >random_walker</span><span class=p >(</span><span class=n >membranes</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >labels</span><span class=p >:</span><span class=n >LabelsData</span><span class=p >):</span>
    <span class=sd >"""Random walker algorithm for segmentation from markers.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    data : array_like</span>
<span class=sd >        Image to be segmented in phases. Gray-level `data` can be two- or</span>
<span class=sd >        three-dimensional; multichannel data can be three- or four-</span>
<span class=sd >        dimensional with `channel_axis` specifying the dimension containing</span>
<span class=sd >        channels. Data spacing is assumed isotropic unless the `spacing`</span>
<span class=sd >        keyword argument is used.</span>
<span class=sd >    labels : array_like</span>
<span class=sd >        Array of seed markers labeled with different positive integers</span>
<span class=sd >        for different phases. Zero-labeled pixels are unlabeled pixels.</span>
<span class=sd >        Negative labels correspond to inactive pixels that are not taken</span>
<span class=sd >        into account (they are removed from the graph). If labels are not</span>
<span class=sd >        consecutive integers, the labels array will be transformed so that</span>
<span class=sd >        labels are consecutive. In the multichannel case, `labels` should have</span>
<span class=sd >        the same shape as a single channel of `data`, i.e. without the final</span>
<span class=sd >        dimension denoting channels.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    output : ndarray</span>
<span class=sd >        * If `return_full_prob` is False, array of ints of same shape</span>
<span class=sd >          and data type as `labels`, in which each pixel has been</span>
<span class=sd >          labeled according to the marker that reached the pixel first</span>
<span class=sd >          by anisotropic diffusion.</span>
<span class=sd >        * If `return_full_prob` is True, array of floats of shape</span>
<span class=sd >          `(nlabels, labels.shape)`. `output[label_nb, i, j]` is the</span>
<span class=sd >          probability that label `label_nb` reaches the pixel `(i, j)`</span>
<span class=sd >          first.</span>
<span class=sd >    </span>
<span class=sd >    See Also</span>
<span class=sd >    --------</span>
<span class=sd >    seeded_watershed : watershed segmentation</span>
<span class=sd >        A segmentation algorithm based on mathematical morphology</span>
<span class=sd >        and "flooding" of regions from markers.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    Multichannel inputs are scaled with all channel data combined. Ensure all</span>
<span class=sd >    channels are separately normalized prior to running this algorithm.</span>
<span class=sd >    The `spacing` argument is specifically for anisotropic datasets, where</span>
<span class=sd >    data points are spaced differently in one or more spatial dimensions.</span>
<span class=sd >    Anisotropic data is commonly encountered in medical imaging.</span>
<span class=sd >    The algorithm was first proposed in [1]_.</span>
<span class=sd >    The algorithm solves the diffusion equation at infinite times for</span>
<span class=sd >    sources placed on markers of each phase in turn. A pixel is labeled with</span>
<span class=sd >    the phase that has the greatest probability to diffuse first to the pixel.</span>
<span class=sd >    The diffusion equation is solved by minimizing x.T L x for each phase,</span>
<span class=sd >    where L is the Laplacian of the weighted graph of the image, and x is</span>
<span class=sd >    the probability that a marker of the given phase arrives first at a pixel</span>
<span class=sd >    by diffusion (x=1 on markers of the phase, x=0 on the other markers, and</span>
<span class=sd >    the other coefficients are looked for). Each pixel is attributed the label</span>
<span class=sd >    for which it has a maximal value of x. The Laplacian L of the image</span>
<span class=sd >    is defined as:</span>
<span class=sd >       - L_ii = d_i, the number of neighbors of pixel i (the degree of i)</span>
<span class=sd >       - L_ij = -w_ij if i and j are adjacent pixels</span>
<span class=sd >    The weight w_ij is a decreasing function of the norm of the local gradient.</span>
<span class=sd >    This ensures that diffusion is easier between pixels of similar values.</span>
<span class=sd >    When the Laplacian is decomposed into blocks of marked and unmarked</span>
<span class=sd >    pixels::</span>
<span class=sd >        L = M B.T</span>
<span class=sd >            B A</span>
<span class=sd >    with first indices corresponding to marked pixels, and then to unmarked</span>
<span class=sd >    pixels, minimizing x.T L x for one phase amount to solving::</span>
<span class=sd >        A x = - B x_m</span>
<span class=sd >    where x_m = 1 on markers of the given phase, and 0 on other markers.</span>
<span class=sd >    This linear system is solved in the algorithm using a direct method for</span>
<span class=sd >    small images, and an iterative method for larger images.</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] Leo Grady, Random walks for image segmentation, IEEE Trans Pattern</span>
<span class=sd >        Anal Mach Intell. 2006 Nov;28(11):1768-83.</span>
<span class=sd >        :DOI:`10.1109/TPAMI.2006.233`.</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class=sd >    &gt;&gt;&gt; a = np.zeros((10, 10)) + 0.2 * rng.random((10, 10))</span>
<span class=sd >    &gt;&gt;&gt; a[5:8, 5:8] += 1</span>
<span class=sd >    &gt;&gt;&gt; b = np.zeros_like(a, dtype=np.int32)</span>
<span class=sd >    &gt;&gt;&gt; b[3, 3] = 1  # Marker for first phase</span>
<span class=sd >    &gt;&gt;&gt; b[6, 6] = 2  # Marker for second phase</span>
<span class=sd >    &gt;&gt;&gt; random_walker(a, b)  # doctest: +SKIP</span>
<span class=sd >    array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class=sd >           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >_random_walker</span><span class=p >(</span><span class=n >membranes</span><span class=p >,</span> <span class=n >labels</span><span class=p >)</span></div>

<div class=viewcode-block  id=local_minima_seeded_watershed ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.local_minima_seeded_watershed.html#root_viewer.analysis.functions.labeling.local_minima_seeded_watershed">[docs]</a><span class=k >def</span> <span class=nf >local_minima_seeded_watershed</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >spot_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >10</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >0</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""</span>
<span class=sd >    Segment cells in images with fluorescently marked membranes.</span>
<span class=sd >    The two sigma parameters allow tuning the segmentation result. The first sigma controls how close detected cells</span>
<span class=sd >    can be (spot_sigma) and the second controls how precise segmented objects are outlined (outline_sigma). Under the</span>
<span class=sd >    hood, this filter applies two Gaussian blurs, local minima detection and a seeded watershed.</span>
<span class=sd >    </span>
<span class=sd >    Finds the watershed basins in `image` flooded from given `labels`.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray (2-D, 3-D, ...)</span>
<span class=sd >        Data array.</span>
<span class=sd >    spot_sigma: float</span>
<span class=sd >        The sigma parameter for the Gaussian blur applied to the image before local minima detection. Controls how close detected cells</span>
<span class=sd >    outline_sigma: float</span>
<span class=sd >        The sigma parameter for the Gaussian blur applied to the image before watershed segmentation. Controls how precise segmented objects are outlined.</span>
<span class=sd >    can be</span>

<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    out : ndarray</span>
<span class=sd >        A labeled matrix of the same type and shape as markers</span>
<span class=sd >    </span>
<span class=sd >    See Also</span>
<span class=sd >    --------</span>
<span class=sd >    random_walker : random walker segmentation</span>
<span class=sd >        A segmentation algorithm based on anisotropic diffusion, usually</span>
<span class=sd >        slower than the watershed but with good results on noisy data and</span>
<span class=sd >        boundaries with holes.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    This function implements a watershed algorithm [1]_ [2]_ that apportions</span>
<span class=sd >    pixels into marked basins. The algorithm uses a priority queue to hold</span>
<span class=sd >    the pixels with the metric for the priority queue being pixel value, then</span>
<span class=sd >    the time of entry into the queue - this settles ties in favor of the</span>
<span class=sd >    closest marker.</span>
<span class=sd >    Some ideas taken from</span>
<span class=sd >    Soille, "Automated Basin Delineation from Digital Elevation Models Using</span>
<span class=sd >    Mathematical Morphology", Signal Processing 20 (1990) 171-182</span>
<span class=sd >    The most important insight in the paper is that entry time onto the queue</span>
<span class=sd >    solves two problems: a pixel should be assigned to the neighbor with the</span>
<span class=sd >    largest gradient or, if there is no gradient, pixels on a plateau should</span>
<span class=sd >    be split between markers on opposite sides.</span>
<span class=sd >    This implementation converts all arguments to specific, lowest common</span>
<span class=sd >    denominator types, then passes these to a C algorithm.</span>
<span class=sd >    Markers can be determined manually, or automatically using for example</span>
<span class=sd >    the local minima of the gradient of the image, or the local maxima of the</span>
<span class=sd >    distance function to the background for separating overlapping objects</span>
<span class=sd >    (see example).</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</span>
<span class=sd >    .. [2] http://cmm.ensmp.fr/~beucher/wtshed.html</span>
<span class=sd >    .. [3] Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and</span>
<span class=sd >           Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation</span>
<span class=sd >           Algorithms. ICPR 2014, pp 996-1001. :DOI:`10.1109/ICPR.2014.181`</span>
<span class=sd >           https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</span>

<span class=sd >    """</span>

    <span class=n >image</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >image</span><span class=p >)</span>

    <span class=n >spot_blurred</span> <span class=o >=</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >sigma</span><span class=o >=</span><span class=n >spot_sigma</span><span class=p >)</span>

    <span class=n >spots</span> <span class=o >=</span> <span class=n >label</span><span class=p >(</span><span class=n >local_minima</span><span class=p >(</span><span class=n >spot_blurred</span><span class=p >))</span>

    <span class=k >if</span> <span class=n >outline_sigma</span> <span class=o >==</span> <span class=n >spot_sigma</span><span class=p >:</span>
        <span class=n >outline_blurred</span> <span class=o >=</span> <span class=n >spot_blurred</span>
    <span class=k >else</span><span class=p >:</span>
        <span class=n >outline_blurred</span> <span class=o >=</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >sigma</span><span class=o >=</span><span class=n >outline_sigma</span><span class=p >)</span>

    <span class=k >return</span> <span class=n >_watershed</span><span class=p >(</span><span class=n >outline_blurred</span><span class=p >,</span> <span class=n >spots</span><span class=p >)</span></div>


<div class=viewcode-block  id=thresholded_local_minima_seeded_watershed ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.thresholded_local_minima_seeded_watershed.html#root_viewer.analysis.functions.labeling.thresholded_local_minima_seeded_watershed">[docs]</a><span class=k >def</span> <span class=nf >thresholded_local_minima_seeded_watershed</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >spot_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >3</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >0</span><span class=p >,</span> <span class=n >minimum_intensity</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >500</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""</span>
<span class=sd >    Segment cells in images with marked membranes that have a high signal intensity.</span>
<span class=sd >    The two sigma parameters allow tuning the segmentation result. The first sigma controls how close detected cells</span>
<span class=sd >    can be (spot_sigma) and the second controls how precise segmented objects are outlined (outline_sigma). Under the</span>
<span class=sd >    hood, this filter applies two Gaussian blurs, local minima detection and a seeded watershed.</span>
<span class=sd >    Afterwards, all objects are removed that have an average intensity below a given minimum_intensity</span>
<span class=sd >    """</span>
    <span class=n >labels</span> <span class=o >=</span> <span class=n >local_minima_seeded_watershed</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >spot_sigma</span><span class=o >=</span><span class=n >spot_sigma</span><span class=p >,</span> <span class=n >outline_sigma</span><span class=o >=</span><span class=n >outline_sigma</span><span class=p >)</span>

    <span class=c1 ># measure intensities</span>
    <span class=n >stats</span> <span class=o >=</span> <span class=n >regionprops</span><span class=p >(</span><span class=n >labels</span><span class=p >,</span> <span class=n >image</span><span class=p >)</span>
    <span class=n >intensities</span> <span class=o >=</span> <span class=p >[</span><span class=n >r</span><span class=o >.</span><span class=n >mean_intensity</span> <span class=k >for</span> <span class=n >r</span> <span class=ow >in</span> <span class=n >stats</span><span class=p >]</span>

    <span class=c1 ># filter labels with low intensity</span>
    <span class=n >new_label_indices</span><span class=p >,</span> <span class=n >_</span><span class=p >,</span> <span class=n >_</span> <span class=o >=</span> <span class=n >_relabel_sequential</span><span class=p >((</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >intensities</span><span class=p >)</span> <span class=o >&gt;</span> <span class=n >minimum_intensity</span><span class=p >)</span> <span class=o >*</span> <span class=n >np</span><span class=o >.</span><span class=n >arange</span><span class=p >(</span><span class=n >labels</span><span class=o >.</span><span class=n >max</span><span class=p >()))</span>
    <span class=n >new_label_indices</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >insert</span><span class=p >(</span><span class=n >new_label_indices</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >)</span>
    <span class=n >new_labels</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >take</span><span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >new_label_indices</span><span class=p >,</span> <span class=n >np</span><span class=o >.</span><span class=n >uint32</span><span class=p >),</span> <span class=n >labels</span><span class=p >)</span>

    <span class=k >return</span> <span class=n >new_labels</span></div>


<div class=viewcode-block  id=connected_component_labeling ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.connected_component_labeling.html#root_viewer.analysis.functions.labeling.connected_component_labeling">[docs]</a><span class=k >def</span> <span class=nf >connected_component_labeling</span><span class=p >(</span><span class=n >binary_image</span><span class=p >:</span> <span class=n >LabelsData</span><span class=p >,</span> <span class=n >exclude_on_edges</span><span class=p >:</span> <span class=nb >bool</span> <span class=o >=</span> <span class=kc >False</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""</span>
<span class=sd >    Takes a binary image and produces a label image with all separated objects labeled with</span>
<span class=sd >    different integer numbers.</span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    exclude_on_edges : bool, optional</span>
<span class=sd >        Whether or not to clear objects connected to the label image border/planes (either xy, xz or yz).</span>
<span class=sd >    """</span>
    <span class=k >if</span> <span class=n >exclude_on_edges</span><span class=p >:</span>
        <span class=c1 ># processing the image, which is not a timelapse</span>
        <span class=k >return</span> <span class=n >remove_labels_on_edges</span><span class=p >(</span><span class=n >label</span><span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >binary_image</span><span class=p >)))</span>

    <span class=k >else</span><span class=p >:</span>
        <span class=k >return</span> <span class=n >label</span><span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >binary_image</span><span class=p >))</span></div>

<div class=viewcode-block  id=skeletonize ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.labeling.skeletonize.html#root_viewer.analysis.functions.labeling.skeletonize">[docs]</a><span class=k >def</span> <span class=nf >skeletonize</span><span class=p >(</span><span class=n >image</span><span class=p >:</span> <span class=n >LabelsData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""</span>
<span class=sd >    Skeletonize labeled objects in an image. This can be useful to reduce objects such as neurons, roots and vessels</span>
<span class=sd >    with variable thickness to single pixel lines for further analysis.</span>
<span class=sd >    """</span>
    <span class=kn >from</span> <span class=nn >skimage</span> <span class=kn >import</span> <span class=n >morphology</span>
    <span class=k >if</span> <span class=n >image</span><span class=o >.</span><span class=n >max</span><span class=p >()</span> <span class=o >==</span> <span class=mi >1</span><span class=p >:</span>
        <span class=k >return</span> <span class=n >morphology</span><span class=o >.</span><span class=n >skeletonize</span><span class=p >(</span><span class=n >image</span><span class=p >)</span>
    <span class=k >else</span><span class=p >:</span>
        <span class=n >result</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >zeros</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >shape</span><span class=p >)</span>
        <span class=k >for</span> <span class=n >i</span> <span class=ow >in</span> <span class=nb >range</span><span class=p >(</span><span class=mi >1</span><span class=p >,</span> <span class=n >image</span><span class=o >.</span><span class=n >max</span><span class=p >()</span> <span class=o >+</span> <span class=mi >1</span><span class=p >):</span>
            <span class=n >skeleton</span> <span class=o >=</span> <span class=n >morphology</span><span class=o >.</span><span class=n >skeletonize</span><span class=p >(</span><span class=n >image</span> <span class=o >==</span> <span class=n >i</span><span class=p >)</span>
            <span class=n >result</span> <span class=o >=</span> <span class=n >skeleton</span> <span class=o >*</span> <span class=n >i</span> <span class=o >+</span> <span class=n >result</span>
        <span class=k >return</span> <span class=n >result</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >int</span><span class=p >)</span></div>
</pre></div> </article> </div> </div> </main> </div> <footer class=md-footer > <div class=md-footer-nav > <nav class="md-footer-nav__inner md-grid"> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright > <div class=md-footer-copyright__highlight > &#169; Copyright 2022. </div> Created using <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.3.0. and <a href="https://github.com/bashtage/sphinx-material/">Material for Sphinx</a> </div> </div> </div> </footer> <script src="../../../../_static/javascripts/application.js"></script> <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>