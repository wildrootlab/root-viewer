<!DOCTYPE html> <html lang=en > <meta charset=utf-8  /> <meta name=viewport  content="width=device-width, initial-scale=1.0" /> <meta name=viewport  content="width=device-width,initial-scale=1"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name="lang:clipboard.copy" content="Copy to clipboard"> <meta name="lang:clipboard.copied" content="Copied to clipboard"> <meta name="lang:search.language" content=en > <meta name="lang:search.pipeline.stopwords" content=True > <meta name="lang:search.pipeline.trimmer" content=True > <meta name="lang:search.result.none" content="No matching documents"> <meta name="lang:search.result.one" content="1 matching document"> <meta name="lang:search.result.other" content="# matching documents"> <meta name="lang:search.tokenizer" content="[\s\-]+"> <link href="https://fonts.gstatic.com/" rel=preconnect  crossorigin> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel=stylesheet > <style> body, input { font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif } code, kbd, pre { font-family: "Roboto Mono", "Courier New", Courier, monospace } </style> <link rel=stylesheet  href="../../../../_static/stylesheets/application.css"/> <link rel=stylesheet  href="../../../../_static/stylesheets/application-palette.css"/> <link rel=stylesheet  href="../../../../_static/stylesheets/application-fixes.css"/> <link rel=stylesheet  href="../../../../_static/fonts/material-icons.css"/> <meta name=theme-color  content="#51DBBA"> <script src="../../../../_static/javascripts/modernizr.js"></script> <title>root_viewer.analysis.functions.filtering &#8212; Root Viewer</title> <link rel=stylesheet  type="text/css" href="../../../../_static/pygments.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/togglebutton.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/copybutton.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/mystnb.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/sphinx-thebe.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <link rel=stylesheet  type="text/css" href="../../../../_static/styles.css" /> <script data-url_root="../../../../" id=documentation_options  src="../../../../_static/documentation_options.js"></script> <script src="../../../../_static/jquery.js"></script> <script src="../../../../_static/underscore.js"></script> <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script> <script src="../../../../_static/doctools.js"></script> <script src="../../../../_static/sphinx_highlight.js"></script> <script src="../../../../_static/clipboard.min.js"></script> <script src="../../../../_static/copybutton.js"></script> <script src="../../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script> <script>let toggleHintShow = 'Click to show';</script> <script>let toggleHintHide = 'Click to hide';</script> <script>let toggleOpenOnPrint = 'true';</script> <script src="../../../../_static/togglebutton.js"></script> <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script> <script src="../../../../_static/design-tabs.js"></script> <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js" const thebe_selector = ".thebe,.cell" const thebe_selector_input = "pre" const thebe_selector_output = ".output, .cell_output" </script> <script async=async  src="../../../../_static/sphinx-thebe.js"></script> <link rel="shortcut icon" href="../../../../_static/favicon.ico"/> <link rel=index  title=Index  href="../../../../genindex.html" /> <link rel=search  title=Search  href="../../../../search.html" /> <body dir=ltr data-md-color-primary=dark-blue data-md-color-accent=#66E0F2> <svg class=md-svg > <defs data-children-count=0 > <svg xmlns="http://www.w3.org/2000/svg" width=416  height=448  viewBox="0 0 416 448" id=__github ><path fill=currentColor  d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle  data-md-toggle=drawer  type=checkbox  id=__drawer > <input class=md-toggle  data-md-toggle=search  type=checkbox  id=__search > <label class=md-overlay  data-md-component=overlay  for=__drawer ></label> <a href="#_modules/root_viewer/analysis/functions/filtering" tabindex=1  class=md-skip > Skip to content </a> <header class=md-header  data-md-component=header > <nav class="md-header-nav md-grid"> <div class="md-flex navheader"> <div class="md-flex__cell md-flex__cell--shrink"> <a href="../../../../intro.html" title="Root Viewer" class="md-header-nav__button md-logo"> <img src="../../../../_static/logo_dark.png" height=26  alt="Root Viewer logo"> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer ></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title > <span class=md-header-nav__topic >Root Viewer</span> <span class=md-header-nav__topic > root_viewer.analysis.functions.filtering </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search ></label> <div class=md-search  data-md-component=search  role=dialog > <label class=md-search__overlay  for=__search ></label> <div class=md-search__inner  role=search > <form class=md-search__form  action="../../../../search.html" method=get  name=search > <input type=text  class=md-search__input  name=q  placeholder=Search  autocapitalize=off  autocomplete=off  spellcheck=false  data-md-component=query  data-md-state=active > <label class="md-icon md-search__icon" for=__search ></label> <button type=reset  class="md-icon md-search__icon" data-md-component=reset  tabindex=-1 > &#xE5CD; </button> </form> <div class=md-search__output > <div class=md-search__scrollwrap  data-md-scrollfix> <div class=md-search-result  data-md-component=result > <div class=md-search-result__meta > Type to start searching </div> <ol class=md-search-result__list ></ol> </div> </div> </div> </div> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source > <a href="https://github.com/wildrootlab/root-viewer" title="Go to repository" class=md-source  data-md-source=github > <div class=md-source__icon > <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width=28  height=28 > <use xlink:href="#__github" width=24  height=24 ></use> </svg> </div> <div class=md-source__repository > wildrood/root-viewer </div> </a> </div> </div> <script src="../../../../_static/javascripts/version_dropdown.js"></script> <script> var json_loc = "../../../../"versions.json"", target_loc = "../../../../../", text = "Versions"; $( document ).ready( add_version_dropdown(json_loc, target_loc, text)); </script> </div> </nav> </header> <div class=md-container > <main class=md-main > <div class="md-main__inner md-grid" data-md-component=container > <div class="md-sidebar md-sidebar--primary" data-md-component=navigation > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--primary" data-md-level=0 > <div class=md-nav__source > <a href="https://github.com/wildrootlab/root-viewer" title="Go to repository" class=md-source  data-md-source=github > <div class=md-source__icon > <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width=28  height=28 > <use xlink:href="#__github" width=24  height=24 ></use> </svg> </div> <div class=md-source__repository > wildrood/root-viewer </div> </a> </div> <ul class=md-nav__list > <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Getting started</span></span> <li class=md-nav__item > <a href="../../../../intro/installation.html" class=md-nav__link >Installation</a> <li class=md-nav__item > <a href="../../../../intro/quickstart.html" class=md-nav__link >Quickstart</a> <li class=md-nav__item > <a href="../../../../intro/layers.html" class=md-nav__link >Layers</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Segmentation</span></span> <li class=md-nav__item > <a href="../../../../usage/Advanced.html" class=md-nav__link >Advanced Segmentations</a> <li class=md-nav__item > <span class="md-nav__link caption"><span class=caption-text >Image Functions</span></span> <li class=md-nav__item > <a href="../../../../usage/Filtering.html" class=md-nav__link >Filtering</a> <li class=md-nav__item > <a href="../../../../usage/Thresholding.html" class=md-nav__link >Thresholding</a> <li class=md-nav__item > <a href="../../../../usage/Labeling.html" class=md-nav__link >Labeling</a> <li class=md-nav__item > <a href="../../../../usage/Misc.html" class=md-nav__link >Misc</a> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc > <div class=md-sidebar__scrollwrap > <div class=md-sidebar__inner > <nav class="md-nav md-nav--secondary"> <ul class=md-nav__list  data-md-scrollfix=""> </ul> </nav> </div> </div> </div> <div class=md-content > <article class="md-content__inner md-typeset" role=main > <h1 id=modules-root-viewer-analysis-functions-filtering--page-root >Source code for root_viewer.analysis.functions.filtering</h1><div class=highlight ><pre>
<span></span><span class=kn >from</span> <span class=nn >napari.types</span> <span class=kn >import</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >LabelsData</span>
<span class=kn >import</span> <span class=nn >numpy</span> <span class=k >as</span> <span class=nn >np</span>
<span class=kn >from</span> <span class=nn >scipy</span> <span class=kn >import</span> <span class=n >ndimage</span> <span class=k >as</span> <span class=n >ndi</span>
<span class=kn >from</span> <span class=nn >skimage.restoration</span> <span class=kn >import</span> <span class=n >rolling_ball</span>


<div class=viewcode-block  id=gaussian_blur ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.gaussian_blur.html#root_viewer.analysis.functions.filtering.gaussian_blur">[docs]</a><span class=k >def</span> <span class=nf >gaussian_blur</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >1</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Multi-dimensional Gaussian filter</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : array-like</span>
<span class=sd >        Input image (grayscale or color) to filter.</span>
<span class=sd >    sigma : scalar or sequence of scalars, optional</span>
<span class=sd >        Standard deviation for Gaussian kernel. The standard</span>
<span class=sd >        deviations of the Gaussian filter are given for each axis as a</span>
<span class=sd >        sequence, or as a single number, in which case it is equal for</span>
<span class=sd >        all axes.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    filtered_image : ndarray</span>
<span class=sd >        the filtered image</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    This function is a wrapper around :func:`scipy.ndi.gaussian_filter`.</span>
<span class=sd >    Integer arrays are converted to float.</span>
<span class=sd >    The ``output`` should be floating point data type since gaussian converts</span>
<span class=sd >    to float provided ``image``. If ``output`` is not provided, another array</span>
<span class=sd >    will be allocated and returned as the result.</span>
<span class=sd >    </span>
<span class=sd >    The multi-dimensional filter is implemented as a sequence of</span>
<span class=sd >    one-dimensional convolution filters. The intermediate arrays are</span>
<span class=sd >    stored in the same data type as the output. Therefore, for output</span>
<span class=sd >    types with a limited precision, the results may be imprecise</span>
<span class=sd >    because intermediate results may be stored with insufficient</span>
<span class=sd >    precision.</span>
<span class=sd >    """</span>
    <span class=kn >from</span> <span class=nn >skimage.filters</span> <span class=kn >import</span> <span class=n >gaussian</span>
    <span class=k >return</span> <span class=n >gaussian</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >sigma</span><span class=p >)</span></div>


<div class=viewcode-block  id=gaussian_laplace ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.gaussian_laplace.html#root_viewer.analysis.functions.filtering.gaussian_laplace">[docs]</a><span class=k >def</span> <span class=nf >gaussian_laplace</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >sigma</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Multidimensional Laplace filter using Gaussian second derivatives.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    input : ndarray</span>
<span class=sd >        The input array.</span>
<span class=sd >    sigma : float</span>
<span class=sd >        The standard deviations of the Gaussian filter are given for</span>
<span class=sd >        each axis as a sequence, or as a single number, in which case</span>
<span class=sd >        it is equal for all axes.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    laplace : ndarray</span>
<span class=sd >        The array in which to place the output, or the dtype of the returned array. By default an array of the same dtype as input will be created.</span>
<span class=sd >    </span>
<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-gaussian_laplace-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >gaussian_laplace</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >sigma</span><span class=p >)</span></div>

<div class=viewcode-block  id=percentile_filter ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.percentile_filter.html#root_viewer.analysis.functions.filtering.percentile_filter">[docs]</a><span class=k >def</span> <span class=nf >percentile_filter</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >percentile</span> <span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >50</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""The percentile filter is similar to the median-filter but it allows specifying the percentile.</span>
<span class=sd >    The percentile-filter with percentile==50 is equal to the median-filter.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    percentile : scalar</span>
<span class=sd >        The percentile parameter may be less than zero, i.e.,</span>
<span class=sd >        percentile = -20 equals percentile = 80</span>
<span class=sd >    size_foot : flaot</span>
<span class=sd >        Gives the shape that is taken from the input array, at every element position, to define the input to the filter function. We adjust size to the number of dimensions of the input array, so that, if the size is 2, then the actual size used for the filtering is (2,2,2). </span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    percentile_filter : ndarray</span>
<span class=sd >        Filtered array. Has the same shape as `input`.</span>
<span class=sd >    </span>
<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-percentile_filter-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >percentile_filter</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >percentile</span><span class=o >=</span><span class=n >percentile</span><span class=p >,</span> <span class=n >size</span><span class=o >=</span><span class=nb >int</span><span class=p >(</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >))</span></div>

<div class=viewcode-block  id=sobel ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.sobel.html#root_viewer.analysis.functions.filtering.sobel">[docs]</a><span class=k >def</span> <span class=nf >sobel</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >axis</span> <span class=p >:</span> <span class=nb >int</span> <span class=o >=</span> <span class=mi >0</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Sobel edge filter.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    axis : int, optional</span>
<span class=sd >        Axis along which the gradient is calculated. Default is 0.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    sobel : ndarray</span>
<span class=sd >        The result of the filter.</span>

<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    The Sobel filter is a discrete differentiation operator, computing an</span>
<span class=sd >    approximation of the gradient of the image intensity function. It is</span>
<span class=sd >    based on convolving the image with a small, separable, and integer</span>
<span class=sd >    valued filter in the horizontal and vertical directions. The</span>
<span class=sd >    derivative approximations are more accurate when the filter is</span>
<span class=sd >    applied to smoothed images (using, for example, a Gaussian filter</span>
<span class=sd >    before applying the Sobel filter in each direction). The Sobel</span>
<span class=sd >    operator uses a 3x3 pixel neighborhood.</span>

<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-sobel-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >sobel</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >))</span></div>

<div class=viewcode-block  id=sobel_3d ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.sobel_3d.html#root_viewer.analysis.functions.filtering.sobel_3d">[docs]</a><span class=k >def</span> <span class=nf >sobel_3d</span><span class=p >(</span><span class=n >image</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Sobel edge filter in 3D</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    axis : int, optional</span>
<span class=sd >        Axis along which the gradient is calculated. Default is 0.</span>
<span class=sd >    mode : str, optional</span>
<span class=sd >        The ``mode`` parameter determines how the array borders are</span>
<span class=sd >        handled, where ``cval`` is the value when mode is equal to</span>
<span class=sd >        'constant'. Default is 'reflect'.</span>
<span class=sd >    cval : scalar, optional</span>
<span class=sd >        Value to fill past edges of input if ``mode`` is 'constant'.</span>
<span class=sd >        Default is 0.0</span>

<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-sobel-1.png</span>
<span class=sd >    """</span>
    <span class=n >kernel</span> <span class=o >=</span> <span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >([</span>
        <span class=p >[</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >0</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >]</span>
        <span class=p >],</span> <span class=p >[</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >0</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >1</span><span class=p >,</span> <span class=o >-</span><span class=mi >6</span><span class=p >,</span> <span class=mi >1</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >0</span><span class=p >]</span>
        <span class=p >],</span> <span class=p >[</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >0</span><span class=p >],</span>
            <span class=p >[</span><span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >0</span><span class=p >]</span>
        <span class=p >]</span>
    <span class=p >])</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >convolve</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >kernel</span><span class=p >)</span></div>


<div class=viewcode-block  id=white_tophat ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.white_tophat.html#root_viewer.analysis.functions.filtering.white_tophat">[docs]</a><span class=k >def</span> <span class=nf >white_tophat</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Multidimensional white tophat filter.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    input : array_like</span>
<span class=sd >        Input.</span>
<span class=sd >    size : tuple of ints</span>
<span class=sd >        Shape of a flat and full structuring element used for the filter.</span>
<span class=sd >        Optional if `footprint` or `structure` is provided.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    output : ndarray</span>
<span class=sd >        Result of the filter of `input` with `structure`.</span>

<span class=sd >    See also</span>
<span class=sd >    --------</span>
<span class=sd >    black_tophat</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >white_tophat</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=nb >int</span><span class=p >(</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >),</span> <span class=p >)</span></div>


<div class=viewcode-block  id=black_tophat ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.black_tophat.html#root_viewer.analysis.functions.filtering.black_tophat">[docs]</a><span class=k >def</span> <span class=nf >black_tophat</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Multidimensional black tophat filter.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    input : array_like</span>
<span class=sd >        Input.</span>
<span class=sd >    size : tuple of ints, optional</span>
<span class=sd >        Shape of a flat and full structuring element used for the filter.</span>
<span class=sd >        Optional if `footprint` or `structure` is provided.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    black_tophat : ndarray</span>
<span class=sd >        Result of the filter of `input` with `structure`.</span>
<span class=sd >    </span>
<span class=sd >    See also</span>
<span class=sd >    --------</span>
<span class=sd >    white_tophat</span>

<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >black_tophat</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=nb >int</span><span class=p >(</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >))</span></div>


<div class=viewcode-block  id=minimum_filter ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.minimum_filter.html#root_viewer.analysis.functions.filtering.minimum_filter">[docs]</a><span class=k >def</span> <span class=nf >minimum_filter</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Calculate a multidimensional minimum filter. Can be used for noise and background removal.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ImageData</span>
<span class=sd >    size : flaot</span>
<span class=sd >        Gives the shape that is taken from the input array, at every element position, to define the input to the filter function. We adjust size to the number of dimensions of the input array, so that, if the size is 2, then the actual size used for the filtering is (2,2,2). </span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    minimum_filter : ndarray</span>
<span class=sd >        Filtered array. Has the same shape as `input`.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    A sequence of modes (one per axis) is only supported when the footprint is</span>
<span class=sd >    separable. Otherwise, a single mode string must be provided.</span>
<span class=sd >    </span>
<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-minimum_filter-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >minimum_filter</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >)</span></div>


<div class=viewcode-block  id=median_filter ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.median_filter.html#root_viewer.analysis.functions.filtering.median_filter">[docs]</a><span class=k >def</span> <span class=nf >median_filter</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Calculate a multidimensional median filter.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ImageData</span>
<span class=sd >    size : flaot</span>
<span class=sd >        Gives the shape that is taken from the input array, at every element position, to define the input to the filter function. We adjust size to the number of dimensions of the input array, so that, if the size is 2, then the actual size used for the filtering is (2,2,2). </span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    median_filter : ndarray</span>
<span class=sd >        Filtered array. Has the same shape as `input`.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes</span>
<span class=sd >    the specialised function `scipy.signal.medfilt2d` may be faster. It is</span>
<span class=sd >    however limited to constant mode with ``cval=0``.</span>
<span class=sd >    </span>
<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-median_filter-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >median_filter</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=nb >int</span><span class=p >(</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >))</span></div>


<div class=viewcode-block  id=maximum_filter ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.maximum_filter.html#root_viewer.analysis.functions.filtering.maximum_filter">[docs]</a><span class=k >def</span> <span class=nf >maximum_filter</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Calculate a multidimensional maximum filter. In the context of cell segmentation it can be used to make membranes wider and close small gaps of insufficient staining.</span>

<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ImageData</span>
<span class=sd >    size : flaot</span>
<span class=sd >        Gives the shape that is taken from the input array, at every element position, to define the input to the filter function. We adjust size to the number of dimensions of the input array, so that, if the size is 2, then the actual size used for the filtering is (2,2,2). </span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    maximum_filter : ndarray</span>
<span class=sd >        Filtered array. Has the same shape as `input`.</span>

<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    A sequence of modes (one per axis) is only supported when the footprint is</span>
<span class=sd >    separable. Otherwise, a single mode string must be provided.</span>
<span class=sd >   </span>
<span class=sd >    .. image:: ../../images/skimage/scipy-ndimage-maximum_filter-1.png</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >maximum_filter</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >)</span></div>


<div class=viewcode-block  id=morphological_gradient ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.morphological_gradient.html#root_viewer.analysis.functions.filtering.morphological_gradient">[docs]</a><span class=k >def</span> <span class=nf >morphological_gradient</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >size</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span><span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >""" Apply gradient filter (similar to the Sobel operator) for edge detection / edge enhancement. This is similar to applying a Gaussian-blur to an image and afterwards the gradient operator.</span>
<span class=sd >    </span>
<span class=sd >    The morphological gradient is calculated as the difference between a</span>
<span class=sd >    dilation and an erosion of the input with a given structuring element.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image: array-like</span>
<span class=sd >        Image to detect edges in</span>
<span class=sd >    radius: float</span>
<span class=sd >        The filter will be applied with a kernel size of (radius * 2 + 1)</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    morphological_gradient : ndarray</span>
<span class=sd >        Morphological gradient of `input`.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    For a flat structuring element, the morphological gradient</span>
<span class=sd >    computed at a given point corresponds to the maximal difference</span>
<span class=sd >    between elements of the input among the elements covered by the</span>
<span class=sd >    structuring element centered on the point.</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    &gt;&gt;&gt; from scipy import ndimage</span>
<span class=sd >    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class=sd >    &gt;&gt;&gt; a[2:5, 2:5] = 1</span>
<span class=sd >    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 0, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    &gt;&gt;&gt; # The morphological gradient is computed as the difference</span>
<span class=sd >    &gt;&gt;&gt; # between a dilation and an erosion</span>
<span class=sd >    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) -\\</span>
<span class=sd >    ...  ndimage.grey_erosion(a, size=(3,3))</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 0, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 1, 1, 1, 1, 1, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class=sd >    &gt;&gt;&gt; a[2:5, 2:5] = 1</span>
<span class=sd >    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3</span>
<span class=sd >    &gt;&gt;&gt; a</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 0, 1, 3, 1, 0, 0],</span>
<span class=sd >           [0, 0, 1, 1, 1, 0, 0],</span>
<span class=sd >           [0, 0, 1, 1, 2, 0, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))</span>
<span class=sd >    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class=sd >           [0, 1, 3, 3, 3, 1, 0],</span>
<span class=sd >           [0, 1, 3, 3, 3, 1, 0],</span>
<span class=sd >           [0, 1, 3, 2, 3, 2, 0],</span>
<span class=sd >           [0, 1, 1, 2, 2, 2, 0],</span>
<span class=sd >           [0, 1, 1, 2, 2, 2, 0],</span>
<span class=sd >           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >ndi</span><span class=o >.</span><span class=n >morphological_gradient</span><span class=p >(</span><span class=n >image</span><span class=o >.</span><span class=n >astype</span><span class=p >(</span><span class=nb >float</span><span class=p >),</span> <span class=n >size</span><span class=o >=</span><span class=nb >int</span><span class=p >(</span><span class=n >size</span> <span class=o >*</span> <span class=mi >2</span> <span class=o >+</span> <span class=mi >1</span><span class=p >))</span></div>


<div class=viewcode-block  id=subtract_background ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.subtract_background.html#root_viewer.analysis.functions.filtering.subtract_background">[docs]</a><span class=k >def</span> <span class=nf >subtract_background</span><span class=p >(</span><span class=n >image</span><span class=p >:</span><span class=n >ImageData</span><span class=p >,</span> <span class=n >rolling_ball_radius</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >5</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Estimate background intensity by rolling/translating a kernel. This rolling ball algorithm estimates background intensity for a ndimage in case of uneven exposure. It is a generalization of the frequently used rolling ball algorithm [1]_.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        The image to be filtered.</span>
<span class=sd >    rolling_ball_radius : int, optional</span>
<span class=sd >        Radius of a ball shaped kernel to be rolled/translated in the image.</span>
<span class=sd >        Used if ``kernel = None``.</span>
<span class=sd >   </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    background : ndarray</span>
<span class=sd >        The estimated background of the image.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    For the pixel that has its background intensity estimated (without loss</span>
<span class=sd >    of generality at ``center``) the rolling ball method centers ``kernel``</span>
<span class=sd >    under it and raises the kernel until the surface touches the image umbra</span>
<span class=sd >    at some ``pos=(y,x)``. The background intensity is then estimated</span>
<span class=sd >    using the image intensity at that position (``image[pos]``) plus the</span>
<span class=sd >    difference of ``kernel[center] - kernel[pos]``.</span>
<span class=sd >    This algorithm assumes that dark pixels correspond to the background. If</span>
<span class=sd >    you have a bright background, invert the image before passing it to the</span>
<span class=sd >    function, e.g., using `utils.invert`. See the gallery example for details.</span>
<span class=sd >    This algorithm is sensitive to noise (in particular salt-and-pepper</span>
<span class=sd >    noise). If this is a problem in your image, you can apply mild</span>
<span class=sd >    gaussian smoothing before passing the image to this function.</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] Sternberg, Stanley R. "Biomedical image processing." Computer 1</span>
<span class=sd >           (1983): 22-34. :DOI:`10.1109/MC.1983.1654163`</span>
<span class=sd >   </span>
<span class=sd >    .. image:: ../../images/skimage/sphx_glr_plot_rolling_ball_001.png</span>
<span class=sd >    """</span>
    <span class=n >background</span> <span class=o >=</span> <span class=n >rolling_ball</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >radius</span> <span class=o >=</span> <span class=n >rolling_ball_radius</span><span class=p >)</span>
    <span class=k >return</span> <span class=n >image</span> <span class=o >-</span> <span class=n >background</span></div>


<div class=viewcode-block  id=binary_invert ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.binary_invert.html#root_viewer.analysis.functions.filtering.binary_invert">[docs]</a><span class=k >def</span> <span class=nf >binary_invert</span><span class=p >(</span><span class=n >binary_image</span><span class=p >:</span><span class=n >LabelsData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >LabelsData</span><span class=p >:</span>
    <span class=sd >"""Inverts a binary image</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    binary_image : ndarray</span>
<span class=sd >        The binary image to be inverted.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    inverted : ndarray</span>
<span class=sd >        The inverted binary image.</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=p >(</span><span class=n >np</span><span class=o >.</span><span class=n >asarray</span><span class=p >(</span><span class=n >binary_image</span><span class=p >)</span> <span class=o >==</span> <span class=mi >0</span><span class=p >)</span> <span class=o >*</span> <span class=mi >1</span></div>


<div class=viewcode-block  id=sum_images ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.sum_images.html#root_viewer.analysis.functions.filtering.sum_images">[docs]</a><span class=k >def</span> <span class=nf >sum_images</span><span class=p >(</span><span class=n >image1</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >image2</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >factor1</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >1</span><span class=p >,</span> <span class=n >factor2</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >1</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Add two images</span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image1 : ndarray</span>
<span class=sd >        The first image to be added.</span>
<span class=sd >    image2 : ndarray</span>
<span class=sd >        The second image to be added.</span>
<span class=sd >    factor1 : float</span>
<span class=sd >        The factor to multiply the first image with.</span>
<span class=sd >    factor2 : float</span>
<span class=sd >        The factor to multiply the second image with.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    summed : ndarray</span>
<span class=sd >        The summed image.</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >image1</span> <span class=o >*</span> <span class=n >factor1</span> <span class=o >+</span> <span class=n >image2</span> <span class=o >*</span> <span class=n >factor2</span></div>


<div class=viewcode-block  id=multiply_images ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.multiply_images.html#root_viewer.analysis.functions.filtering.multiply_images">[docs]</a><span class=k >def</span> <span class=nf >multiply_images</span><span class=p >(</span><span class=n >image1</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >image2</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Multiply two images</span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image1 : ndarray</span>
<span class=sd >        The first image to be multiplied.</span>
<span class=sd >    image2 : ndarray</span>
<span class=sd >        The second image to be multiplied.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    multiplied : ndarray</span>
<span class=sd >        The multiplied image.</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >image1</span> <span class=o >*</span> <span class=n >image2</span></div>


<div class=viewcode-block  id=divide_images ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.divide_images.html#root_viewer.analysis.functions.filtering.divide_images">[docs]</a><span class=k >def</span> <span class=nf >divide_images</span><span class=p >(</span><span class=n >image1</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >image2</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Divide one image by another</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image1 : ndarray</span>
<span class=sd >        The image to be divided.</span>
<span class=sd >    image2 : ndarray</span>
<span class=sd >        The image to divide by.</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    divided : ndarray</span>
<span class=sd >        The divided image.</span>
<span class=sd >    """</span>
    <span class=k >return</span> <span class=n >image1</span> <span class=o >/</span> <span class=n >image2</span></div>


<div class=viewcode-block  id=invert_image ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.invert_image.html#root_viewer.analysis.functions.filtering.invert_image">[docs]</a><span class=k >def</span> <span class=nf >invert_image</span><span class=p >(</span><span class=n >image</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >signed</span><span class=p >:</span> <span class=nb >bool</span> <span class=o >=</span> <span class=kc >False</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Inverts the intensity range of the input image, so that the dtype maximum</span>
<span class=sd >    is now the dtype minimum, and vice-versa. </span>
<span class=sd >    </span>
<span class=sd >    This operation is slightly different depending on the input dtype:</span>
<span class=sd >    - unsigned integers: subtract the image from the dtype maximum</span>
<span class=sd >    - signed integers: subtract the image from -1 (see Notes)</span>
<span class=sd >    - floats: subtract the image from 1 (if signed_float is False, so we</span>
<span class=sd >      assume the image is unsigned), or from 0 (if signed_float is True).</span>
<span class=sd >    </span>
<span class=sd >    See the examples for clarification.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    signed_float : bool, optional</span>
<span class=sd >        If True and the image is of type float, the range is assumed to</span>
<span class=sd >        be [-1, 1]. If False and the image is of type float, the range is</span>
<span class=sd >        assumed to be [0, 1].</span>
<span class=sd >    </span>
<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    inverted : ndarray</span>
<span class=sd >        Inverted image.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    Ideally, for signed integers we would simply multiply by -1. However,</span>
<span class=sd >    signed integer ranges are asymmetric. For example, for np.int8, the range</span>
<span class=sd >    of possible values is [-128, 127], so that -128 * -1 equals -128! By</span>
<span class=sd >    subtracting from -1, we correctly map the maximum dtype value to the</span>
<span class=sd >    minimum.</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    &gt;&gt;&gt; img = np.array([[100,  0, 200],</span>
<span class=sd >    ...                 [  0, 50,   0],</span>
<span class=sd >    ...                 [ 30,  0, 255]], np.uint8)</span>
<span class=sd >    &gt;&gt;&gt; invert(img)</span>
<span class=sd >    array([[155, 255,  55],</span>
<span class=sd >           [255, 205, 255],</span>
<span class=sd >           [225, 255,   0]], dtype=uint8)</span>
<span class=sd >    &gt;&gt;&gt; img2 = np.array([[ -2, 0, -128],</span>
<span class=sd >    ...                  [127, 0,    5]], np.int8)</span>
<span class=sd >    &gt;&gt;&gt; invert(img2)</span>
<span class=sd >    array([[   1,   -1,  127],</span>
<span class=sd >           [-128,   -1,   -6]], dtype=int8)</span>
<span class=sd >    &gt;&gt;&gt; img3 = np.array([[ 0., 1., 0.5, 0.75]])</span>
<span class=sd >    &gt;&gt;&gt; invert(img3)</span>
<span class=sd >    array([[1.  , 0.  , 0.5 , 0.25]])</span>
<span class=sd >    &gt;&gt;&gt; img4 = np.array([[ 0., 1., -1., -0.25]])</span>
<span class=sd >    &gt;&gt;&gt; invert(img4, signed_float=True)</span>
<span class=sd >    array([[-0.  , -1.  ,  1.  ,  0.25]])</span>
<span class=sd >    """</span>
    <span class=kn >from</span> <span class=nn >skimage</span> <span class=kn >import</span> <span class=n >util</span>
    <span class=k >return</span> <span class=n >util</span><span class=o >.</span><span class=n >invert</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >signed</span><span class=p >)</span></div>

<div class=viewcode-block  id=butterworth ><a class=viewcode-back  href="../../../../usage/filtering/root_viewer.analysis.functions.filtering.butterworth.html#root_viewer.analysis.functions.filtering.butterworth">[docs]</a><span class=k >def</span> <span class=nf >butterworth</span><span class=p >(</span><span class=n >image</span><span class=p >:</span> <span class=n >ImageData</span><span class=p >,</span> <span class=n >cutoff_frequency_ratio</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mf >0.005</span><span class=p >,</span> <span class=n >high_pass</span><span class=p >:</span> <span class=nb >bool</span> <span class=o >=</span> <span class=kc >False</span><span class=p >,</span>
                <span class=n >order</span><span class=p >:</span> <span class=nb >float</span> <span class=o >=</span> <span class=mi >2</span><span class=p >)</span> <span class=o >-&gt;</span> <span class=n >ImageData</span><span class=p >:</span>
    <span class=sd >"""Apply a Butterworth filter to enhance high or low frequency features.</span>
<span class=sd >    This filter is defined in the Fourier domain.</span>
<span class=sd >    </span>
<span class=sd >    Parameters</span>
<span class=sd >    ----------</span>
<span class=sd >    image : (M[, N[, ..., P]][, C]) ndarray</span>
<span class=sd >        Input image.</span>
<span class=sd >    cutoff_frequency_ratio : float, optional</span>
<span class=sd >        Determines the position of the cut-off relative to the shape of the</span>
<span class=sd >        FFT.</span>
<span class=sd >    high_pass : bool, optional</span>
<span class=sd >        Whether to perform a high pass filter. If False, a low pass filter is</span>
<span class=sd >        performed.</span>
<span class=sd >    order : float, optional</span>
<span class=sd >        Order of the filter which affects the slope near the cut-off. Higher</span>
<span class=sd >        order means steeper slope in frequency space.</span>

<span class=sd >    Returns</span>
<span class=sd >    -------</span>
<span class=sd >    result : ndarray</span>
<span class=sd >        The Butterworth-filtered image.</span>
<span class=sd >    </span>
<span class=sd >    Notes</span>
<span class=sd >    -----</span>
<span class=sd >    A band-pass filter can be achieved by combining a high-pass and low-pass</span>
<span class=sd >    filter. The user can increase `npad` if boundary artifacts are apparent.</span>
<span class=sd >    The "Butterworth filter" used in image processing textbooks (e.g. [1]_,</span>
<span class=sd >    [2]_) is often the square of the traditional Butterworth filters as</span>
<span class=sd >    described by [3]_, [4]_. The squared version will be used here if</span>
<span class=sd >    `squared_butterworth` is set to ``True``. The lowpass, squared Butterworth</span>
<span class=sd >    filter is given by the following expression for the lowpass case:</span>

<span class=sd >    .. math::</span>

<span class=sd >        H_{low}(f) = \\frac{1}{1 + \\left(\\frac{f}{c f_s}\\right)^{2n}}</span>
<span class=sd >    </span>
<span class=sd >    with the highpass case given by</span>

<span class=sd >    .. math::</span>

<span class=sd >        H_{hi}(f) = 1 - H_{low}(f)</span>
<span class=sd >    </span>
<span class=sd >    where :math:`f=\\sqrt{\\sum_{d=0}^{\\mathrm{ndim}} f_{d}^{2}}` is the</span>
<span class=sd >    absolute value of the spatial frequency, :math:`f_s` is the sampling</span>
<span class=sd >    frequency, :math:`c` the ``cutoff_frequency_ratio``, and :math:`n` is the</span>
<span class=sd >    filter `order` [1]_. When ``squared_butterworth=False``, the square root of</span>
<span class=sd >    the above expressions are used instead.</span>
<span class=sd >    Note that ``cutoff_frequency_ratio`` is defined in terms of the sampling</span>
<span class=sd >    frequency, :math:`f_s`. The FFT spectrum covers the Nyquist range</span>
<span class=sd >    (:math:`[-f_s/2, f_s/2]`) so ``cutoff_frequency_ratio`` should have a value</span>
<span class=sd >    between 0 and 0.5. The frequency response (gain) at the cutoff is 0.5 when</span>
<span class=sd >    ``squared_butterworth`` is true and :math:`1/\\sqrt{2}` when it is false.</span>
<span class=sd >    </span>
<span class=sd >    Examples</span>
<span class=sd >    --------</span>
<span class=sd >    Apply a high-pass and low-pass Butterworth filter to a grayscale and</span>
<span class=sd >    color image respectively:</span>
<span class=sd >    &gt;&gt;&gt; from skimage.data import camera, astronaut</span>
<span class=sd >    &gt;&gt;&gt; from skimage.filters import butterworth</span>
<span class=sd >    &gt;&gt;&gt; high_pass = butterworth(camera(), 0.07, True, 8)</span>
<span class=sd >    &gt;&gt;&gt; low_pass = butterworth(astronaut(), 0.01, False, 4, channel_axis=-1)</span>

<span class=sd >    .. image:: ../../images/skimage/sphx_glr_plot_butterworth_001.png</span>
<span class=sd >    </span>
<span class=sd >    References</span>
<span class=sd >    ----------</span>
<span class=sd >    .. [1] Russ, John C., et al. The Image Processing Handbook, 3rd. Ed.</span>
<span class=sd >           1999, CRC Press, LLC.</span>
<span class=sd >    .. [2] Birchfield, Stan. Image Processing and Analysis. 2018. Cengage</span>
<span class=sd >           Learning.</span>
<span class=sd >    .. [3] Butterworth, Stephen. "On the theory of filter amplifiers."</span>
<span class=sd >           Wireless Engineer 7.6 (1930): 536-541.</span>
<span class=sd >    .. [4] https://en.wikipedia.org/wiki/Butterworth_filter</span>
<span class=sd >    """</span>
    <span class=kn >from</span> <span class=nn >skimage.filters</span> <span class=kn >import</span> <span class=n >butterworth</span>
    <span class=k >return</span> <span class=n >butterworth</span><span class=p >(</span><span class=n >image</span><span class=p >,</span> <span class=n >cutoff_frequency_ratio</span><span class=p >,</span> <span class=n >high_pass</span><span class=p >,</span> <span class=n >order</span><span class=p >)</span></div>
</pre></div> </article> </div> </div> </main> </div> <footer class=md-footer > <div class=md-footer-nav > <nav class="md-footer-nav__inner md-grid"> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright > <div class=md-footer-copyright__highlight > &#169; Copyright 2022. </div> Created using <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.3.0. and <a href="https://github.com/bashtage/sphinx-material/">Material for Sphinx</a> </div> </div> </div> </footer> <script src="../../../../_static/javascripts/application.js"></script> <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>